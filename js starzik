let canvas, ctx, currentScene, inventory, gameState, scenes;
let dialogVisible = false;
let currentDialogOptions = null;

const itemIcons = {
  ≈Åopatka: "‚õèÔ∏è",
  Ko≈õƒá: "ü¶¥",
  "Dow√≥d osobisty": "ü™™",
  List: "‚úâÔ∏è"
};

function log(message) {
  console.log(message);
  document.getElementById("debug").textContent = message;
}

function checkIntercomCodeDirect(code) {
  if (code === "1015") {
    gameState.intercomUnlocked = true;
    hideCodeInput();
    showDialog("Domofon wydaje d≈∫wiƒôk i drzwi siƒô otwierajƒÖ!", 3000);
  } else {
    hideCodeInput();
    showDialog("Nieprawid≈Çowy kod. Sprawd≈∫ wskaz√≥wki w li≈õcie.", 3000);
  }
}

function initGame() {
  try {
    canvas = document.getElementById("canvas");
    if (!canvas) {
      console.error("Canvas element not found!");
      return false;
    }

    ctx = canvas.getContext("2d");
    if (!ctx) {
      console.error("Cannot get 2D context!");
      return false;
    }

    currentScene = "menu";
    inventory = [];
    gameState = {
      hasSpade: false,
      hasBone: false,
      boneVisible: false,
      gaveBone: false,
      gotInfo: false,
      gotCode: false,
      wellOpened: false,
      hasID: false,
      gotLetter: false,
      canEnter: false,
      intercomUnlocked: false,
      hasIntercomCode: false
    };

    scenes = {
      menu: new MenuScene(),
      courtyard: new CourtyardScene(),
      apartment: new ApartmentScene(),
      ending: new EndingScene()
    };

    canvas.addEventListener("click", handleClick);
    canvas.addEventListener("mousemove", handleMouseMove);

    console.log("Game initialized successfully!");
    gameLoop();
    return true;
  } catch (error) {
    console.error("Error initializing game:", error);
    log("‚ùå B≈ÇƒÖd inicjalizacji: " + error.message);
    return false;
  }
}

function handleClick(e) {
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;

  const codeInput = document.getElementById("codeInput");
  if (codeInput.style.display === "block") {
    return;
  }

  if (dialogVisible) {
    return;
  }

  scenes[currentScene].click(x, y);
}

function handleMouseMove(e) {
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;

  scenes[currentScene].hover(x, y);
}

function showDialog(text, duration = 3000) {
  const dialogEl = document.getElementById("dialog");
  dialogEl.innerHTML = text;
  dialogEl.style.display = "block";
  dialogVisible = true;

  if (duration > 0) {
    setTimeout(() => {
      hideDialog();
    }, duration);
  }
}

function showDialogWithOptions(text, options, npcName = "") {
  currentDialogOptions = options;
  let html = "";
  if (npcName) {
    html += `<div style="background: rgba(100,100,100,0.8); padding: 5px 10px; margin-bottom: 10px; border-radius: 4px; font-weight: bold; color: #fff; font-size: 12px;">${npcName}</div>`;
  }
  html += `<div>${text}</div><div style="margin-top: 10px;">`;
  options.forEach((option, index) => {
    html += `<div class="dialog-option" onclick="selectOption(${index})">${option.text}</div>`;
  });

  if (
    options.length > 0 &&
    !options.some(
      (opt) =>
        opt.text.includes("Mi≈Çego") ||
        opt.text.includes("Dziƒôkujƒô") ||
        opt.text.includes("Pa")
    )
  ) {
    html += `<div class="dialog-option" onclick="hideDialog()" style="background: rgba(80,80,80,0.3); margin-top: 8px;">‚Üê Zako≈Ñcz rozmowƒô</div>`;
  }

  html += "</div>";

  const dialogEl = document.getElementById("dialog");
  dialogEl.innerHTML = html;
  dialogEl.style.display = "block";
  dialogVisible = true;
}

function selectOption(index) {
  if (currentDialogOptions && currentDialogOptions[index]) {
    const option = currentDialogOptions[index];
    if (option.action) {
      setTimeout(() => {
        option.action();
      }, 100);
    }
  }
}

function hideDialog() {
  document.getElementById("dialog").style.display = "none";
  dialogVisible = false;
  currentDialogOptions = null;
}

function addItem(item) {
  if (!inventory.includes(item)) {
    inventory.push(item);
    updateInventoryDisplay();
  }
}

function removeItem(item) {
  const index = inventory.indexOf(item);
  if (index > -1) {
    inventory.splice(index, 1);
    updateInventoryDisplay();
  }
}

function hasItem(item) {
  return inventory.includes(item);
}

function updateInventoryDisplay() {
  const slots = document.querySelectorAll(".inventory-slot");
  slots.forEach((slot, index) => {
    slot.textContent = "";
    slot.className = "inventory-slot empty";
    slot.title = "";
    slot.onclick = null;
  });

  inventory.forEach((item, index) => {
    if (index < slots.length) {
      const slot = slots[index];
      slot.textContent = itemIcons[item] || "‚ùì";
      slot.className = "inventory-slot";
      slot.title = item;
      slot.onclick = () => useItem(item);
    }
  });
}

function useItem(item) {
  if (item === "List") {
    gameState.hasIntercomCode = true;
    showLetterContent();
  } else {
    showDialog(`KliknƒÖ≈Çe≈õ na: ${item}`, 2000);
  }
}

function showLetterContent() {
  const letterContent = `
        <div style="background: #f5f5f5; color: #333; padding: 15px; border-radius: 5px; margin: 10px 0;">
            <div style="text-align: center; margin-bottom: 10px; font-weight: bold;">
                üìÆ POCZTA POLSKA üìÆ
            </div>
            <div style="margin-bottom: 15px;">
                <strong>Do:</strong> J√≥zef Dy≈Çka<br>
                <strong>Od:</strong> UrzƒÖd Miasta ≈öwiƒôtoch≈Çowice<br>
                <strong>Data:</strong> 15 pa≈∫dziernika 2013
            </div>
            <div style="border-top: 1px solid #ccc; padding-top: 10px;">
                <p><strong>Szanowny Panie J√≥zefie,</strong></p>
                <p>Informujemy, ≈ºe w zwiƒÖzku z planowanƒÖ rozbi√≥rkƒÖ budynku przy ulicy Cmentarnej,
                prosimo o opuszczenie lokalu do dnia 30. pa≈∫dziernika 2013 roku.</p>
                <p>Szczeg√≥≈Çy dotyczƒÖce przeprowadzki znajdzie Pan w swoim mieszkaniu.</p>
                <p style="margin-top: 15px;">
                    <em>Z powa≈ºaniem,<br>
                    UrzƒÖd Miasta</em>
                </p>
            </div>
        </div>
        <div style="text-align: center; margin-top: 10px;">
            <button onclick="hideDialog()" style="padding: 8px 16px; background: #555; color: #ddd; border: 1px solid #666; border-radius: 4px; cursor: pointer;">
                Zamknij list
            </button>
        </div>
    `;
  showDialog(letterContent, 0);
}

function showCodeInput() {
  hideDialog();
  document.getElementById("codeInput").style.display = "block";
  document.getElementById("codeInput").dataset.type = "sewer";
  document.getElementById("codeInput").querySelector("h3").textContent =
    "Wprowad≈∫ kod do k≈Ç√≥dki:";
  if (gameState.gotCode) {
    document.getElementById("codeInput").querySelector("h3").textContent =
      "Wprowad≈∫ kod do k≈Ç√≥dki:\nWskaz√≥wka: tu≈º po wojnie, mia≈Ça 22 lata...";
  }
}

function hideCodeInput() {
  document.getElementById("codeInput").style.display = "none";
  document.getElementById("codeField").value = "";
  delete document.getElementById("codeInput").dataset.type;
}

function checkCode() {
  const code = document.getElementById("codeField").value;
  if (document.getElementById("codeInput").dataset.type === "intercom") {
    checkIntercomCodeDirect(code);
  } else {
    checkCodeDirect(code);
  }
}

function showIntercomKeypad() {
  hideDialog();
  document.getElementById("codeInput").style.display = "block";
  document.getElementById("codeInput").dataset.type = "intercom";
  const heading = document.getElementById("codeInput").querySelector("h3");
  heading.textContent = "Wprowad≈∫ kod do domofonu:";
}

function checkCodeDirect(code) {
  if (code === "1947") {
    gameState.wellOpened = true;
    addItem("Dow√≥d osobisty");
    gameState.hasID = true;
    showDialog(
      "Uda≈Ço siƒô! W kratce kanalizacyjnej by≈Ç Tw√≥j stary dow√≥d osobisty.",
      4000
    );
  } else {
    if (gameState.gotCode) {
      showDialog(
        "Nieprawid≈Çowy kod. Spr√≥buj ponownie. Wskaz√≥wka: tu≈º po wojnie, mia≈Ça 22 lata...",
        4000
      );
    } else {
      showDialog(
        "Nieprawid≈Çowy kod. Mo≈ºe potrzebujesz wiƒôcej informacji?",
        3000
      );
    }
  }
}

function changeScene(sceneName) {
  currentScene = sceneName;
  hideDialog();

  // Zatrzymaj muzykƒô z menu gdy przechodzimy do innej sceny
  if (currentScene !== "menu" && scenes.menu && scenes.menu.backgroundMusic) {
    scenes.menu.backgroundMusic.pause();
  }

  // Poka≈º ekwipunek gdy gra siƒô rozpoczyna
  if (sceneName === "courtyard") {
    document.getElementById("inventoryGrid").parentElement.style.display =
      "block";
  }
}

class Scene {
  constructor() {
    this.clickAreas = [];
    this.hoveredArea = null;
  }

  addArea(x, y, w, h, action) {
    this.clickAreas.push({ x, y, w, h, action });
  }

  click(x, y) {
    for (let area of this.clickAreas) {
      if (
        x >= area.x &&
        x <= area.x + area.w &&
        y >= area.y &&
        y <= area.y + area.h
      ) {
        area.action();
        break;
      }
    }
  }

  hover(x, y) {
    let found = false;
    for (let area of this.clickAreas) {
      if (
        x >= area.x &&
        x <= area.x + area.w &&
        y >= area.y &&
        y <= area.y + area.h
      ) {
        this.hoveredArea = area;
        canvas.style.cursor = "pointer";
        found = true;
        break;
      }
    }
    if (!found) {
      this.hoveredArea = null;
      canvas.style.cursor = "crosshair";
    }
  }
}

// Dodaj to do klasy MenuScene w konstruktorze:

class MenuScene extends Scene {
  constructor() {
    super();
    this.animation = 0;
    this.backgroundMusic = new Audio("https://files.catbox.moe/ngqi9t.mp3");
    this.backgroundMusic.loop = true;
    this.backgroundMusic.volume = 0.3;
    this.musicStarted = false;

    // D≈∫wiƒôk kartki papieru
    this.paperSound = new Audio("https://files.catbox.moe/h99gh2.mp3");
    this.paperSound.volume = 0.2;

    // NOWY SYSTEM DESZCZU
    this.rainDrops = [];
    this.initRain();

    // SYSTEM B≈ÅYSKAWIC
    this.lightning = {
      active: false,
      intensity: 0,
      timer: 0,
      nextStrike: this.getRandomLightningTime(),
      duration: 0,
      branches: []
    };

    // NOWY SYSTEM KARTKI WPROWADZAJƒÑCEJ
    this.introPaper = {
      visible: false,
      animation: 0,
      maxAnimation: 60,
      text:
        "Rok 2013, ≈öwiƒôtoch≈Çowice...\nStarzik pakuje ostatnie rzeczy przed wyprowadzkƒÖ.\n\nCo zosta≈Ço w jego starym mieszkaniu?\nJakie tajemnice kryje budynek przy Cmentarnej?\n\nRozwiƒÖ≈º zagadkƒô i odkryj prawdƒô!",
      scale: 0,
      rotation: 0,
      opacity: 0
    };

    // Obszar klikniƒôcia na ca≈Çe menu do uruchomienia muzyki
    this.addArea(0, 0, 800, 600, () => this.startMusic());

    // ZMIANA: Przycisk teraz pokazuje kartkƒô zamiast od razu i≈õƒá do gry
    this.addArea(300, 300, 200, 50, () => this.showIntroPaper());
    this.addArea(300, 370, 200, 50, () =>
      showDialog(
        "Kr√≥tka gra przygodowa - prequel escape roomu Familock w ≈öwiƒôtoch≈Çowicach.",
        0
      )
    );
    this.addArea(300, 440, 200, 50, () => {
      showDialog("Przekierowywanie do Familock...", 2000);
      setTimeout(() => window.open("https://www.familock.pl", "_blank"), 1000);
    });
  }

  // NOWA METODA - pokazanie kartki wprowadzajƒÖcej
  showIntroPaper() {
    this.introPaper.visible = true;
    this.introPaper.animation = 0;
    this.paperSound
      .play()
      .catch((e) => console.log("Nie mo≈ºna odtworzyƒá d≈∫wiƒôku kartki:", e));

    // USU≈É WSZYSTKIE obszary klikniƒôcia przycisk√≥w
    this.clickAreas = this.clickAreas.filter((area) => {
      // Zostaw tylko obszar muzyki (je≈õli jest)
      return area.x === 0 && area.y === 0 && area.w === 800 && area.h === 600;
    });

    // Dodaj nowy obszar klikniƒôcia na przycisk "DO GRY" (bƒôdzie widoczny po animacji)
    setTimeout(() => {
      // Przycisk na kartce jest w ≈õrodku ekranu, wiƒôc wsp√≥≈Çrzƒôdne to:
      // ≈örodek ekranu (400) minus po≈Çowa szeroko≈õci przycisku (50) = 350
      // Pozycja Y: 400 (≈õrodek kartki transformowanej)
      this.addArea(350, 400, 100, 40, () => {
        changeScene("courtyard");
      });
    }, 1000); // Czeka sekundƒô na zako≈Ñczenie animacji
  }

  // NOWA METODA - aktualizacja animacji kartki
  updateIntroPaper() {
    if (!this.introPaper.visible) return;

    if (this.introPaper.animation < this.introPaper.maxAnimation) {
      this.introPaper.animation++;

      // Easing function dla p≈Çynnej animacji
      const progress = this.introPaper.animation / this.introPaper.maxAnimation;
      const eased = 1 - Math.pow(1 - progress, 3); // ease-out cubic

      this.introPaper.scale = eased;
      this.introPaper.opacity = eased;
      this.introPaper.rotation = (1 - eased) * 0.3; // Lekka rotacja na poczƒÖtku
    }
  }

  // NOWA METODA - rysowanie kartki wprowadzajƒÖcej
  drawIntroPaper() {
    if (!this.introPaper.visible || this.introPaper.opacity <= 0) return;

    ctx.save();

    // P√≥≈Çprzezroczyste t≈Ço
    ctx.globalAlpha = this.introPaper.opacity * 0.8;
    ctx.fillStyle = "rgba(20, 22, 34, 0.7)";
    ctx.fillRect(0, 0, 800, 600);

    // Transformacje kartki
    ctx.translate(400, 300); // ≈örodek ekranu
    ctx.rotate(this.introPaper.rotation);
    ctx.scale(this.introPaper.scale, this.introPaper.scale);
    ctx.globalAlpha = this.introPaper.opacity;

    // Cie≈Ñ kartki
    ctx.shadowColor = "rgba(0, 0, 0, 0.5)";
    ctx.shadowBlur = 20;
    ctx.shadowOffsetX = 8;
    ctx.shadowOffsetY = 8;

    // T≈Ço kartki - stary papier
    ctx.fillStyle = "#F5F1E8";
    ctx.fillRect(-200, -150, 400, 300);

    // Obramowanie kartki
    ctx.strokeStyle = "#D4C4A8";
    ctx.lineWidth = 2;
    ctx.strokeRect(-200, -150, 400, 300);

    // Plamy na papierze (efekt starzenia)
    ctx.globalAlpha = this.introPaper.opacity * 0.3;
    ctx.fillStyle = "#E8D4B0";
    ctx.beginPath();
    ctx.ellipse(-120, -80, 30, 15, 0.3, 0, 2 * Math.PI);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(150, 100, 25, 12, -0.2, 0, 2 * Math.PI);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(-80, 120, 20, 10, 0.5, 0, 2 * Math.PI);
    ctx.fill();

    ctx.globalAlpha = this.introPaper.opacity;

    // Reset cienia dla tekstu
    ctx.shadowColor = "transparent";
    ctx.shadowBlur = 0;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;

    // Tytu≈Ç na kartce
    ctx.fillStyle = "#2C1810";
    ctx.font = "bold 24px serif";
    ctx.textAlign = "center";
    ctx.fillText("STARZIK: PREQUEL", 0, -100);

    // Linia pod tytu≈Çem
    ctx.strokeStyle = "#8B4513";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(-80, -85);
    ctx.lineTo(80, -85);
    ctx.stroke();

    // Tekst g≈Ç√≥wny (podzielony na linie)
    ctx.font = "14px serif";
    ctx.fillStyle = "#2C1810";
    ctx.textAlign = "center";

    const lines = this.introPaper.text.split("\n");
    lines.forEach((line, index) => {
      ctx.fillText(line, 0, -50 + index * 20);
    });

    // Przycisk "DO GRY" (pokazuje siƒô po animacji)
    if (this.introPaper.animation >= this.introPaper.maxAnimation) {
      // T≈Ço przycisku - sp√≥jne z g≈Ç√≥wnymi przyciskami
      ctx.fillStyle = "#2d3748";
      ctx.fillRect(-50, 100, 100, 40);

      // Obramowanie przycisku
      ctx.strokeStyle = "#4a5568";
      ctx.lineWidth = 2;
      ctx.strokeRect(-50, 100, 100, 40);

      // Tekst przycisku - bia≈Çy dla maksymalnej czytelno≈õci
      ctx.fillStyle = "#ffffff";
      ctx.font = "bold 16px serif";
      ctx.textAlign = "center";
      ctx.fillText("DO GRY", 0, 125);
    }

    ctx.restore();
  }

  // NOWA METODA - losowy czas do nastƒôpnej b≈Çyskawicy
  getRandomLightningTime() {
    return Math.random() * 300 + 180; // 3-8 sekund (przy 60 FPS)
  }

  // NOWA METODA - generowanie b≈Çyskawicy
  createLightning() {
    this.lightning.active = true;
    this.lightning.intensity = 1;
    this.lightning.duration = Math.random() * 20 + 10; // 10-30 klatek
    this.lightning.branches = [];

    // G≈Ç√≥wna ga≈ÇƒÖ≈∫ b≈Çyskawicy
    const startX = Math.random() * 800;
    const startY = 0;
    this.lightning.branches.push(
      this.generateLightningBranch(startX, startY, 0, Math.random() * 400 + 200)
    );

    // Dodatkowe ga≈Çƒôzie (30% szans)
    if (Math.random() < 0.3) {
      const branchX = Math.random() * 800;
      this.lightning.branches.push(
        this.generateLightningBranch(branchX, 0, 0, Math.random() * 300 + 150)
      );
    }
  }

  // NOWA METODA - generowanie ga≈Çƒôzi b≈Çyskawicy
  generateLightningBranch(startX, startY, startAngle, maxLength) {
    const points = [{ x: startX, y: startY }];
    let currentX = startX;
    let currentY = startY;
    let currentAngle = startAngle;
    let remainingLength = maxLength;

    while (remainingLength > 0 && currentY < 600) {
      // Losowa zmiana kierunku
      currentAngle += (Math.random() - 0.5) * 0.8;

      // Losowa d≈Çugo≈õƒá segmentu
      const segmentLength = Math.random() * 30 + 15;
      const actualLength = Math.min(segmentLength, remainingLength);

      currentX += Math.sin(currentAngle) * actualLength;
      currentY += Math.cos(currentAngle) * actualLength + actualLength * 0.7; // bias w d√≥≈Ç

      points.push({ x: currentX, y: currentY });
      remainingLength -= actualLength;

      // Szansa na rozga≈Çƒôzienie (10%)
      if (Math.random() < 0.1 && remainingLength > 50) {
        const branchAngle = currentAngle + (Math.random() - 0.5) * 1.5;
        const branchLength = remainingLength * (Math.random() * 0.6 + 0.2);
        // Rekursywnie dodaj mniejszƒÖ ga≈ÇƒÖ≈∫
        const subBranch = this.generateLightningBranch(
          currentX,
          currentY,
          branchAngle,
          branchLength
        );
        return { main: points, branches: [subBranch] };
      }
    }

    return { main: points, branches: [] };
  }

  // NOWA METODA - aktualizacja b≈Çyskawic
  updateLightning() {
    this.lightning.timer++;

    if (this.lightning.active) {
      this.lightning.duration--;

      // Migotanie b≈Çyskawicy
      if (this.lightning.duration > 0) {
        this.lightning.intensity = Math.random() * 0.7 + 0.3;
      } else {
        this.lightning.active = false;
        this.lightning.intensity = 0;
        this.lightning.nextStrike =
          this.lightning.timer + this.getRandomLightningTime();
      }
    } else {
      // Sprawd≈∫ czy czas na nowƒÖ b≈Çyskawicƒô
      if (this.lightning.timer >= this.lightning.nextStrike) {
        this.createLightning();
        this.lightning.timer = 0;
      }
    }
  }

  // NOWA METODA - rysowanie b≈Çyskawic
  drawLightning() {
    if (!this.lightning.active || this.lightning.intensity <= 0) return;

    ctx.save();

    // Globalne o≈õwietlenie od b≈Çyskawicy
    ctx.globalAlpha = this.lightning.intensity * 0.4;
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(0, 0, 800, 600);

    // Rysowanie ga≈Çƒôzi b≈Çyskawicy
    ctx.globalAlpha = this.lightning.intensity;
    ctx.strokeStyle = "#ffffff";
    ctx.shadowColor = "#a0c4ff";
    ctx.shadowBlur = 15;
    ctx.lineWidth = 3;

    for (let branch of this.lightning.branches) {
      this.drawLightningBranch(branch);
    }

    ctx.restore();
  }

  // NOWA METODA - rysowanie pojedynczej ga≈Çƒôzi
  drawLightningBranch(branch) {
    // Rysuj g≈Ç√≥wnƒÖ ga≈ÇƒÖ≈∫
    if (branch.main && branch.main.length > 1) {
      ctx.beginPath();
      ctx.moveTo(branch.main[0].x, branch.main[0].y);

      for (let i = 1; i < branch.main.length; i++) {
        ctx.lineTo(branch.main[i].x, branch.main[i].y);
      }
      ctx.stroke();

      // Wewnƒôtrzny blask
      ctx.save();
      ctx.strokeStyle = "#e0f0ff";
      ctx.lineWidth = 1;
      ctx.shadowBlur = 5;
      ctx.beginPath();
      ctx.moveTo(branch.main[0].x, branch.main[0].y);
      for (let i = 1; i < branch.main.length; i++) {
        ctx.lineTo(branch.main[i].x, branch.main[i].y);
      }
      ctx.stroke();
      ctx.restore();
    }

    // Rysuj podga≈Çƒôzie
    if (branch.branches) {
      for (let subBranch of branch.branches) {
        ctx.save();
        ctx.lineWidth = 2;
        this.drawLightningBranch(subBranch);
        ctx.restore();
      }
    }
  }

  initRain() {
    this.rainDrops = [];
    // Stw√≥rz poczƒÖtkowe krople deszczu
    for (let i = 0; i < 100; i++) {
      this.rainDrops.push(this.createRainDrop());
    }
  }

  // NOWA METODA - tworzenie pojedynczej kropli
  createRainDrop() {
    return {
      x: Math.random() * 800,
      y: Math.random() * 600,
      speed: Math.random() * 3 + 2, // prƒôdko≈õƒá 2-5
      length: Math.random() * 15 + 5, // d≈Çugo≈õƒá 5-20
      opacity: Math.random() * 0.6 + 0.2, // przezroczysto≈õƒá 0.2-0.8
      angle: Math.random() * 0.2 - 0.1 // lekki kƒÖt -0.1 do 0.1
    };
  }

  // NOWA METODA - aktualizacja pozycji kropli
  updateRain() {
    for (let drop of this.rainDrops) {
      // Poruszaj kroplƒô w d√≥≈Ç
      drop.y += drop.speed;
      drop.x += drop.angle * drop.speed; // lekki ruch w bok

      // Je≈õli kropla wysz≈Ça poza ekran, zresetuj na g√≥rze
      if (drop.y > 600) {
        drop.y = -drop.length;
        drop.x = Math.random() * 800;
        drop.speed = Math.random() * 3 + 2;
        drop.length = Math.random() * 15 + 5;
        drop.opacity = Math.random() * 0.6 + 0.2;
        drop.angle = Math.random() * 0.2 - 0.1;
      }

      // Je≈õli kropla wysz≈Ça z boku, przenie≈õ na drugƒÖ stronƒô
      if (drop.x < -10) drop.x = 810;
      if (drop.x > 810) drop.x = -10;
    }
  }

  // NOWA METODA - rysowanie deszczu
  drawRain() {
    ctx.save();

    // Rysuj krople deszczu
    for (let drop of this.rainDrops) {
      ctx.globalAlpha = drop.opacity;
      ctx.strokeStyle = "#a0c4e0"; // bladoniebieska barwa deszczu
      ctx.lineWidth = 1;

      // Narysuj liniƒô kropli
      ctx.beginPath();
      ctx.moveTo(drop.x, drop.y);
      ctx.lineTo(drop.x + drop.angle * drop.length, drop.y + drop.length);
      ctx.stroke();
    }

    // Dodaj efekt mg≈Çy/pary
    const fogGradient = ctx.createLinearGradient(0, 500, 0, 600);
    fogGradient.addColorStop(0, "rgba(200, 220, 240, 0.1)");
    fogGradient.addColorStop(1, "rgba(200, 220, 240, 0.3)");
    ctx.fillStyle = fogGradient;
    ctx.fillRect(0, 500, 800, 100);

    ctx.restore();
  }

  // NOWA METODA - efekt ka≈Çu≈º
  drawPuddles() {
    ctx.save();
    ctx.globalAlpha = 0.3;

    // Ka≈Çu≈ºa 1
    ctx.fillStyle = "#4a6a8a";
    ctx.beginPath();
    ctx.ellipse(150, 580, 40, 8, 0, 0, 2 * Math.PI);
    ctx.fill();

    // Ka≈Çu≈ºa 2
    ctx.beginPath();
    ctx.ellipse(450, 570, 30, 6, 0, 0, 2 * Math.PI);
    ctx.fill();

    // Ka≈Çu≈ºa 3
    ctx.beginPath();
    ctx.ellipse(650, 585, 35, 7, 0, 0, 2 * Math.PI);
    ctx.fill();

    // Odbicia ≈õwiat≈Ça w ka≈Çu≈ºach
    ctx.globalAlpha = 0.2;
    ctx.fillStyle = "#ffffff";
    ctx.beginPath();
    ctx.ellipse(150, 580, 20, 4, 0, 0, 2 * Math.PI);
    ctx.fill();

    ctx.beginPath();
    ctx.ellipse(450, 570, 15, 3, 0, 0, 2 * Math.PI);
    ctx.fill();

    ctx.restore();
  }

  startMusic() {
    if (!this.musicStarted) {
      this.backgroundMusic
        .play()
        .then(() => {
          console.log("Muzyka uruchomiona!");
          this.musicStarted = true;
          // USU≈É obszar klikniƒôcia muzyki
          this.clickAreas = this.clickAreas.filter(
            (area) =>
              !(
                area.x === 0 &&
                area.y === 0 &&
                area.w === 800 &&
                area.h === 600
              )
          );
        })
        .catch((e) => {
          console.log("Nie mo≈ºna odtworzyƒá muzyki:", e);
        });
    }
  }

  render() {
    // Rysuj zdjƒôcie jako t≈Ço
    const img = new Image();
    img.src = "https://i.imgur.com/4eI9vWb.png";
    if (img.complete) {
      ctx.drawImage(img, 0, 0, 800, 600);
    } else {
      // Fallback - gradient jak by≈Ço wcze≈õniej (ale ciemniejszy dla deszczu)
      const gradient = ctx.createLinearGradient(0, 0, 0, 600);
      gradient.addColorStop(0, "#1a1a2e");
      gradient.addColorStop(0.5, "#16213e");
      gradient.addColorStop(1, "#0f0f1e");
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, 800, 600);
    }

    // AKTUALIZUJ I NARYSUJ DESZCZ
    this.updateRain();

    // AKTUALIZUJ I NARYSUJ B≈ÅYSKAWICE
    this.updateLightning();
    this.drawLightning();

    this.drawRain();

    this.animation += 0.02;

    // Dodaj lekkie przyciemnienie przez deszcz (ale nie podczas b≈Çyskawicy)
    if (!this.lightning.active) {
      ctx.fillStyle = "rgba(30, 40, 60, 0.3)";
      ctx.fillRect(0, 0, 800, 600);
    }

    ctx.save();
    ctx.shadowColor = "rgba(200, 200, 255, 0.8)";
    ctx.shadowBlur = 15;
    ctx.shadowOffsetY = Math.sin(this.animation) * 2;
    ctx.fillStyle = "#ffffff"; // Bia≈Çy tytu≈Ç
    ctx.font = "bold 42px Georgia";
    ctx.textAlign = "center";
    ctx.fillText("STARZIK", 400, 160);

    ctx.font = "20px Georgia";
    ctx.fillStyle = "#cccccc"; // Jasny szary podtytu≈Ç
    ctx.fillText("TheSzpil", 400, 190);
    ctx.restore();

    // RESET kolor√≥w przed przyciskami
    ctx.fillStyle = "#ffffff";
    ctx.strokeStyle = "#ffffff";

    // Poka≈º przyciski tylko je≈õli kartka nie jest widoczna
    if (!this.introPaper.visible) {
      this.drawButton(300, 300, 200, 50, "ROZPOCZNIJ GRƒò", "main");
      this.drawButton(300, 370, 200, 50, "O GRZE", "secondary");
      this.drawButton(300, 440, 200, 50, "WWW FAMILOCKA", "secondary");
    }

    // NARYSUJ KA≈ÅU≈ªE NA KO≈ÉCU
    this.drawPuddles();

    // Dodaj informacjƒô o muzyce je≈õli nie jest uruchomiona
    if (!this.musicStarted && !this.introPaper.visible) {
      ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
      ctx.font = "14px Georgia";
      ctx.textAlign = "center";
      ctx.fillText("üîä Kliknij gdziekolwiek aby w≈ÇƒÖczyƒá muzykƒô", 400, 550);
    }

    // AKTUALIZUJ I NARYSUJ KARTKƒò WPROWADZAJƒÑCƒÑ
    this.updateIntroPaper();
    this.drawIntroPaper();

    if (this.hoveredArea && !this.introPaper.visible) {
      ctx.strokeStyle = "#8a8aaa";
      ctx.lineWidth = 2;
      ctx.strokeRect(
        this.hoveredArea.x,
        this.hoveredArea.y,
        this.hoveredArea.w,
        this.hoveredArea.h
      );
    }
  }

  drawButton(x, y, w, h, text, type) {
    ctx.save();

    // Sprawd≈∫ czy mysz jest nad przyciskiem
    const isHovered =
      this.hoveredArea && this.hoveredArea.x === x && this.hoveredArea.y === y;

    if (type === "main") {
      // PRZYCISK G≈Å√ìWNY - prosty i czytelny
      if (isHovered) {
        // Hover: ja≈õniejszy z ciep≈Çym akcentem
        ctx.fillStyle = "#4a5568";
        ctx.fillRect(x, y, w, h);
        ctx.strokeStyle = "#ed8936"; // Ciep≈Çy pomara≈Ñczowy
        ctx.lineWidth = 2;
        ctx.strokeRect(x, y, w, h);
      } else {
        // Normalny: ciemny ale nie za bardzo
        ctx.fillStyle = "#2d3748";
        ctx.fillRect(x, y, w, h);
        ctx.strokeStyle = "#4a5568";
        ctx.lineWidth = 2;
        ctx.strokeRect(x, y, w, h);
      }
      // Tekst zawsze jasny i czytelny
      ctx.fillStyle = "#ffffff";
    } else {
      // PRZYCISKI DRUGORZƒòDNE - jeszcze prostsze
      if (isHovered) {
        ctx.fillStyle = "#3a4555";
        ctx.fillRect(x, y, w, h);
        ctx.strokeStyle = "#5a6a7a";
        ctx.lineWidth = 1;
        ctx.strokeRect(x, y, w, h);
      } else {
        ctx.fillStyle = "#1a202c";
        ctx.fillRect(x, y, w, h);
        ctx.strokeStyle = "#2d3748";
        ctx.lineWidth = 1;
        ctx.strokeRect(x, y, w, h);
      }
      // Tekst ja≈õniejszy przy hover
      ctx.fillStyle = isHovered ? "#ffffff" : "#cbd5e0";
    }

    // Lekki efekt mokro≈õci na g√≥rze przycisku
    if (!this.lightning.active) {
      ctx.globalAlpha = 0.1;
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(x + 5, y + 5, w - 10, 6);
    }

    ctx.restore();

    // Tekst przycisku - bold dla lepszej czytelno≈õci
    ctx.font = "bold 16px Georgia";
    ctx.textAlign = "center";
    ctx.fillText(text, x + w / 2, y + h / 2 + 5);
  }
} // ‚Üê ZAMYKA KLASƒò MenuScene
class CourtyardScene extends Scene {
  constructor() {
    super();
    this.setupAreas();
  }

  setupAreas() {
    this.addArea(350, 450, 100, 80, () => {
      if (gameState.wellOpened) {
        showDialog("Kratka kanalizacyjna jest ju≈º otwarta.");
      } else {
        showCodeInput();
      }
    });

    this.addArea(320, 480, 25, 40, () => {
      if (!gameState.hasSpade) {
        addItem("≈Åopatka");
        gameState.hasSpade = true;
        showDialog("Znalaz≈Çe≈õ ≈Çopatkƒô!");
      } else {
        showDialog("Ju≈º nie ma tu wiƒôcej ≈Çopatek.");
      }
    });

    // Przeniesiony kopczyk ziemi - przy krzakach (na dole)
    this.addArea(650, 560, 16, 12, () => {
      if (gameState.hasBone) {
        if (gameState.boneVisible) {
          addItem("Ko≈õƒá");
          gameState.boneVisible = false;
          showDialog("Podnios≈Çe≈õ starƒÖ ko≈õƒá!");
        } else {
          showDialog("Tu ju≈º wykopa≈Çe≈õ ko≈õƒá.");
        }
      } else if (hasItem("≈Åopatka")) {
        gameState.hasBone = true;
        gameState.boneVisible = true;
        showDialog("Wykopa≈Çe≈õ starƒÖ ko≈õƒá! Mo≈ºesz jƒÖ teraz podnie≈õƒá.");
      } else {
        showDialog("Kopczyk ziemi. Potrzebujƒô czego≈õ do kopania.");
      }
    });

    // Obszar klikniƒôcia dla ko≈õci (gdy jest widoczna) - przesuniƒôty na d√≥≈Ç
    if (gameState.boneVisible) {
      this.addArea(655, 565, 12, 7, () => {
        addItem("Ko≈õƒá");
        gameState.boneVisible = false;
        showDialog("Podnios≈Çe≈õ starƒÖ ko≈õƒá!");
      });
    }

    // Postaci - obszary klikalne
    this.addArea(80, 350, 80, 120, () => this.talkToJanitor()); // Pani sprzƒÖtajƒÖca
    this.addArea(550, 320, 120, 150, () => this.talkToNeighbor()); // Pan Kowalski z psem
    this.addArea(380, 300, 70, 120, () => this.talkToPostman()); // Listonosz

    // Domofon
    this.addArea(475, 290, 25, 40, () => showIntercomKeypad());

    // Nowe drzwi do budynku Cmentarna 5 - teraz wy≈ºej
    this.addArea(390, 250, 60, 120, () => {
      if (gameState.intercomUnlocked) {
        changeScene("apartment");
      } else {
        showDialog("Drzwi sƒÖ zamkniƒôte. Spr√≥buj u≈ºyƒá domofonu...");
      }
    });
  }

  talkToJanitor() {
    if (gameState.gotCode) {
      showDialog(
        "Pani sprzƒÖtajƒÖca: 'Pamiƒôtaj - tu≈º po wojnie, mia≈Çam 22 lata, to by≈Ç rok wielkiej zmiany!'"
      );
    } else if (gameState.gotInfo) {
      const options = [
        {
          text: "SƒÖsiad m√≥wi≈Ç, ≈ºe zna Pani historiƒô kratki...",
          action: () => {
            const riddleOptions = [
              {
                text: "Proszƒô o kod do k≈Ç√≥dki.",
                action: () => {
                  showDialog(
                    "Pani sprzƒÖtajƒÖca: 'To nie tak ≈Çatwo! Musisz sam siƒô domy≈õliƒá. Powiem tylko, ≈ºe to by≈Ç najwa≈ºniejszy rok w moim ≈ºyciu - kiedy siƒô tu przeprowadzi≈Çam. Mia≈Çam wtedy 22 lata i by≈Ço tu≈º po wielkiej wojnie...'"
                  );
                }
              },
              {
                text: "Kiedy Pani siƒô tu przeprowadzi≈Ça?",
                action: () => {
                  gameState.gotCode = true;
                  showDialog(
                    "Pani sprzƒÖtajƒÖca: 'To by≈Ça wielka zmiana - tu≈º po wojnie. Przeprowadzi≈Çam siƒô tu jako m≈Çoda dziewczyna, mia≈Çam wtedy 22 lata.'"
                  );
                }
              }
            ];
            showDialogWithOptions(
              "Pani sprzƒÖtajƒÖca: 'Och! Pytasz o kratkƒô kanalizacyjnƒÖ? To stare miejsce kryje tajemnice...'",
              riddleOptions,
              "üëµ Pani SprzƒÖtajƒÖca"
            );
          }
        },
        {
          text: "Jak siƒô Pani miewa?",
          action: () => {
            showDialog(
              "Pani sprzƒÖtajƒÖca: 'Dobrze, dziƒôkujƒô za pytanie. SprzƒÖtam tu ju≈º od lat!'"
            );
          }
        }
      ];
      showDialogWithOptions(
        "Pani sprzƒÖtajƒÖca: 'Dzie≈Ñ dobry! Jak siƒô masz?'",
        options,
        "üëµ Pani SprzƒÖtajƒÖca"
      );
    } else {
      const options = [
        {
          text: "Czy zna Pani historiƒô tej kratki kanalizacyjnej?",
          action: () => {
            showDialog(
              "Pani sprzƒÖtajƒÖca: 'Pan Kowalski z psem wiƒôcej wie o starych czasach.'"
            );
          }
        },
        {
          text: "Dzie≈Ñ dobry! Piƒôkny wiecz√≥r.",
          action: () => {
            showDialog(
              "Pani sprzƒÖtajƒÖca: 'Rzeczywi≈õcie piƒôkny, choƒá trochƒô ponury!'"
            );
          }
        },
        {
          text: "Co Pani tutaj robi?",
          action: () => {
            showDialog(
              "Pani sprzƒÖtajƒÖca: 'SprzƒÖtam podw√≥rko. Kto≈õ musi dbaƒá o porzƒÖdek!'"
            );
          }
        }
      ];
      showDialogWithOptions(
        "Pani sprzƒÖtajƒÖca: 'Dzie≈Ñ dobry! Piƒôkny wiecz√≥r.'",
        options,
        "üëµ Pani SprzƒÖtajƒÖca"
      );
    }
  }

  talkToNeighbor() {
    if (gameState.gotInfo) {
      const options = [
        {
          text: "Powiedzia≈Ç Pan ju≈º o pani sprzƒÖtajƒÖcej.",
          action: () => {
            showDialog("Pan Kowalski: 'Tak, ona wie wszystko o tym miejscu!'");
          }
        },
        {
          text: "Jak d≈Çugo tu Pan mieszka?",
          action: () => {
            showDialog(
              "Pan Kowalski: 'Od 1943 roku. Pamiƒôtam jeszcze wojnƒô...'"
            );
          }
        }
      ];
      showDialogWithOptions(
        "Pan Kowalski: 'Powiedzia≈Çem ju≈º o pani sprzƒÖtajƒÖcej.'",
        options,
        "üë® Pan Kowalski"
      );
    } else if (gameState.gaveBone) {
      const options = [
        {
          text: "Potrzebujƒô informacji o kratce kanalizacyjnej...",
          action: () => {
            gameState.gotInfo = true;
            showDialog(
              "Pan Kowalski: 'Pani sprzƒÖtajƒÖca zna historiƒô kratki najlepiej. Mieszka tu od dawna!'"
            );
          }
        },
        {
          text: "Burek wyglƒÖda na zadowolonego!",
          action: () => {
            showDialog("Pan Kowalski: 'Tak! Uwielbia ko≈õci! Dziƒôkujƒô!'");
          }
        }
      ];
      showDialogWithOptions(
        "Pan Kowalski: 'Burek jest szczƒô≈õliwy! Czym mogƒô siƒô odwdziƒôczyƒá?'",
        options,
        "üë® Pan Kowalski"
      );
    } else if (hasItem("Ko≈õƒá")) {
      const options = [
        {
          text: "Mam co≈õ dla Burka...",
          action: () => {
            removeItem("Ko≈õƒá");
            gameState.gaveBone = true;
            showDialog("Pan Kowalski: 'Burek uwielbia ko≈õci! Dziƒôkujƒô!'");
          }
        },
        {
          text: "≈Åadny pies!",
          action: () => {
            showDialog(
              "Pan Kowalski: 'To m√≥j Burek. Ale jest niespokojny - szuka czego≈õ do gryzienia.'"
            );
          }
        }
      ];
      showDialogWithOptions(
        "Pan Kowalski: 'Dzie≈Ñ dobry! Burek nie mo≈ºe usiedzieƒá w miejscu.'",
        options,
        "üë® Pan Kowalski"
      );
    } else {
      const options = [
        {
          text: "≈Åadny pies!",
          action: () => {
            showDialog(
              "Pan Kowalski: 'To m√≥j Burek. Ale jest g≈Çodny - szuka czego≈õ do gryzienia.'"
            );
          }
        },
        {
          text: "Jak siƒô Pan miewa?",
          action: () => {
            showDialog(
              "Pan Kowalski: 'Dobrze, ale Burek jest dzi≈õ niespokojny.'"
            );
          }
        }
      ];
      showDialogWithOptions(
        "Pan Kowalski: 'Dzie≈Ñ dobry! Burek szuka czego≈õ do gryzienia.'",
        options,
        "üë® Pan Kowalski"
      );
    }
  }

  talkToPostman() {
    if (gameState.gotLetter) {
      const options = [
        {
          text: "Czy ma Pan jeszcze listy dla mnie?",
          action: () => {
            showDialog("Listonosz: 'Nie, to by≈Ç ostatni list na dzi≈õ.'");
          }
        },
        {
          text: "Dziƒôkujƒô za list!",
          action: () => {
            showDialog("Listonosz: 'Proszƒô bardzo! To moja praca.'");
          }
        }
      ];
      showDialogWithOptions(
        "Listonosz: 'List ju≈º Pan odebra≈Ç.'",
        options,
        "üìÆ Listonosz"
      );
    } else if (hasItem("Dow√≥d osobisty")) {
      const options = [
        {
          text: "Mam dow√≥d osobisty.",
          action: () => {
            gameState.gotLetter = true;
            gameState.canEnter = true;
            addItem("List");
            showDialog("Listonosz: '≈öwietnie! Oto Pana list.'");
          }
        },
        {
          text: "Co to za list?",
          action: () => {
            showDialog(
              "Listonosz: 'Od Urzƒôdu Miasta. Ale muszƒô sprawdziƒá to≈ºsamo≈õƒá.'"
            );
          }
        }
      ];
      showDialogWithOptions(
        "Listonosz: 'Czy ma Pan dow√≥d osobisty?'",
        options,
        "üìÆ Listonosz"
      );
    } else {
      const options = [
        {
          text: "Czy ma Pan list dla mnie?",
          action: () => {
            showDialog(
              "Listonosz: 'Tak, ale potrzebujƒô zobaczyƒá dow√≥d osobisty. Taki przepis!'"
            );
          }
        },
        {
          text: "Dlaczego Pan tutaj stoi?",
          action: () => {
            showDialog(
              "Listonosz: 'Czekam na Pana! Mam wa≈ºny list od Urzƒôdu Miasta.'"
            );
          }
        }
      ];
      showDialogWithOptions(
        "Listonosz: 'Dzie≈Ñ dobry! Potrzebujƒô zobaczyƒá dow√≥d osobisty.'",
        options,
        "üìÆ Listonosz"
      );
    }
  }

  render() {
    // Niebo gradientowe
    const skyGradient = ctx.createLinearGradient(0, 0, 0, 400);
    // ... kod nieba

    // Ksiƒô≈ºyc nad ≈õrodkowym domem
    this.drawMoon();

    // NOWE BUDYNKI
    this.drawBuildings();

    // Ziemia
    ctx.fillStyle = "#2a2520";
    ctx.fillRect(0, 400, 800, 200);

    // Kratka kanalizacyjna - szczeg√≥≈Çowa
    this.drawSewerGrate();

    // ≈Åopatka (je≈õli nie wziƒôta) - szczeg√≥≈Çowa
    if (!gameState.hasSpade) {
      this.drawSpade();
    }

    // Krzaczki po prawej stronie (z nowym kopczykiem)
    this.drawBushes();

    // === POSTACIE (na ko≈Ñcu, ≈ºeby by≈Çy widoczne) ===
    this.drawJanitor(80, 350); // Pani sprzƒÖtajƒÖca - lewy d√≥≈Ç
    this.drawNeighbor(550, 320); // Pan Kowalski z psem - prawy d√≥≈Ç
    this.drawPostman(380, 300); // Listonosz - centrum
  }

  drawMoon() {
    // Pozycja ksiƒô≈ºyca nad ≈õrodkowym budynkiem
    const moonX = 420,
      moonY = 80;

    // G≈Ç√≥wny krƒÖg ksiƒô≈ºyca
    ctx.fillStyle = "#f0f0e0";
    ctx.beginPath();
    ctx.arc(moonX, moonY, 25, 0, 2 * Math.PI);
    ctx.fill();

    // Blask ksiƒô≈ºyca
    const moonGlow = ctx.createRadialGradient(
      moonX,
      moonY,
      25,
      moonX,
      moonY,
      60
    );
    moonGlow.addColorStop(0, "rgba(240, 240, 224, 0.3)");
    moonGlow.addColorStop(0.5, "rgba(240, 240, 224, 0.1)");
    moonGlow.addColorStop(1, "rgba(240, 240, 224, 0)");
    ctx.fillStyle = moonGlow;
    ctx.beginPath();
    ctx.arc(moonX, moonY, 60, 0, 2 * Math.PI);
    ctx.fill();

    // Kratery na ksiƒô≈ºycu
    ctx.fillStyle = "#e0e0d0";
    ctx.beginPath();
    ctx.arc(moonX - 8, moonY - 5, 4, 0, 2 * Math.PI);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(moonX + 6, moonY + 8, 3, 0, 2 * Math.PI);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(moonX + 10, moonY - 10, 2, 0, 2 * Math.PI);
    ctx.fill();

    // Delikatne cienie na ksiƒô≈ºycu
    ctx.fillStyle = "#d0d0c0";
    ctx.beginPath();
    ctx.arc(moonX - 5, moonY + 12, 6, 0, 2 * Math.PI);
    ctx.fill();
  }

  drawBuildings() {
    // Lewy budynek z ceg≈ÇƒÖ
    ctx.fillStyle = "#0f0f0f";
    ctx.fillRect(0, 0, 200, 450);

    // Wz√≥r cegie≈Ç - lewa strona
    ctx.fillStyle = "#1a1a1a";
    for (let y = 0; y < 450; y += 20) {
      for (let x = 0; x <= 200; x += 40) {
        const offsetX = y % 40 === 0 ? 0 : 20;
        ctx.fillStyle = (x + y) % 80 === 0 ? "#151515" : "#1a1a1a";
        const brickWidth = Math.min(38, 200 - (x + offsetX));
        if (brickWidth > 0) {
          ctx.fillRect(x + offsetX, y, brickWidth, 18);
          ctx.fillStyle = "#0a0a0a";
          ctx.fillRect(x + offsetX, y + 18, brickWidth, 2);
          if (x + offsetX + brickWidth < 200) {
            ctx.fillRect(x + offsetX + brickWidth, y, 2, 20);
          }
        }
      }
    }

    // Prawy budynek z ceg≈ÇƒÖ
    ctx.fillStyle = "#0f0f0f";
    ctx.fillRect(600, 0, 200, 450);
    ctx.fillStyle = "#1a1a1a";
    for (let y = 0; y < 450; y += 20) {
      for (let x = 600; x <= 800; x += 40) {
        const offsetX = y % 40 === 0 ? 0 : 20;
        ctx.fillStyle = (x + y) % 100 === 0 ? "#151515" : "#1a1a1a";
        const brickWidth = Math.min(38, 800 - (x + offsetX));
        if (brickWidth > 0) {
          ctx.fillRect(x + offsetX, y, brickWidth, 18);
          ctx.fillStyle = "#0a0a0a";
          ctx.fillRect(x + offsetX, y + 18, brickWidth, 2);
          if (x + offsetX + brickWidth < 800) {
            ctx.fillRect(x + offsetX + brickWidth, y, 2, 20);
          }
        }
      }
    }

    // ≈örodkowy budynek
    ctx.fillStyle = "#141414";
    ctx.fillRect(250, 100, 300, 350);
    ctx.fillStyle = "#1f1f1f";
    for (let y = 100; y < 450; y += 20) {
      for (let x = 250; x <= 550; x += 40) {
        const offsetX = y % 40 === 0 ? 0 : 20;
        ctx.fillStyle = (x + y) % 120 === 0 ? "#1a1a1a" : "#1f1f1f";
        const brickWidth = Math.min(38, 550 - (x + offsetX));
        if (brickWidth > 0) {
          ctx.fillRect(x + offsetX, y, brickWidth, 18);
          ctx.fillStyle = "#0a0a0a";
          ctx.fillRect(x + offsetX, y + 18, brickWidth, 2);
          if (x + offsetX + brickWidth < 550) {
            ctx.fillRect(x + offsetX + brickWidth, y, 2, 20);
          }
        }
      }
    }

    this.drawDetailedWindows();
    this.drawBuildingEntrance();
  }

  drawDetailedWindows() {
    // Inicjalizacja stanu okien je≈õli nie istnieje
    if (!this.windowStates) {
      this.windowStates = {};
      this.windowTimer = 0;
    }

    this.windowTimer++;

    // Co 60 klatek (oko≈Ço 1 sekunda) losowo zmie≈Ñ niekt√≥re okna
    if (this.windowTimer % 60 === 0) {
      // Tylko 10% szans na zmianƒô ka≈ºdego okna
      if (Math.random() < 0.1)
        this.windowStates["30_80"] = !this.windowStates["30_80"];
      if (Math.random() < 0.1)
        this.windowStates["120_180"] = !this.windowStates["120_180"];
      if (Math.random() < 0.1)
        this.windowStates["350_120"] = !this.windowStates["350_120"];
      if (Math.random() < 0.1)
        this.windowStates["280_220"] = !this.windowStates["280_220"];
      if (Math.random() < 0.1)
        this.windowStates["630_80"] = !this.windowStates["630_80"];
    }

    // Okna lewego budynku - niekt√≥re stale ≈õwiecƒÖ
    this.drawWindow(30, 80, this.windowStates["30_80"] || false);
    this.drawWindow(120, 80, false);
    this.drawWindow(30, 180, true); // zawsze ≈õwieci
    this.drawWindow(120, 180, this.windowStates["120_180"] || false);
    this.drawWindow(30, 280, true); // zawsze ≈õwieci
    this.drawWindow(120, 280, false);

    // Okna ≈õrodkowego budynku - usuniƒôto dolne okna ≈ºeby zrobiƒá miejsce na drzwi
    this.drawWindow(280, 150, false);
    this.drawWindow(350, 150, this.windowStates["350_120"] || true); // zazwyczaj ≈õwieci
    this.drawWindow(420, 150, false);

    // Okna prawego budynku
    this.drawWindow(630, 80, this.windowStates["630_80"] || true); // zazwyczaj ≈õwieci
    this.drawWindow(720, 80, false);
    this.drawWindow(630, 180, false);
    this.drawWindow(720, 180, true); // zawsze ≈õwieci
    this.drawWindow(630, 280, false);
    this.drawWindow(720, 280, false);
  }

  drawWindow(x, y, isLit) {
    const windowWidth = 40;
    const windowHeight = 50;

    // Rama okna
    ctx.fillStyle = "#0a0a0a";
    ctx.fillRect(x, y, windowWidth, windowHeight);

    // O≈õcie≈ºnica okna
    ctx.fillStyle = "#050505";
    ctx.fillRect(x + 2, y + 2, windowWidth - 4, windowHeight - 4);

    // Szyba
    if (isLit) {
      ctx.fillStyle = "#6a5a2a";
      ctx.fillRect(x + 4, y + 4, windowWidth - 8, windowHeight - 8);
      ctx.fillStyle = "#8a7a3a";
      ctx.fillRect(x + 8, y + 8, windowWidth - 16, windowHeight - 16);
      // ≈öwiat≈Ço z okna
      ctx.fillStyle = "#aa9a4a";
      ctx.fillRect(x + 6, y + 6, 8, 8);
    } else {
      ctx.fillStyle = "#1a1a2a";
      ctx.fillRect(x + 4, y + 4, windowWidth - 8, windowHeight - 8);
      ctx.fillStyle = "#2a2a3a";
      ctx.fillRect(x + 6, y + 6, 6, 6);
    }

    // Krzy≈º ramy okiennej
    ctx.fillStyle = "#2a2a2a";
    ctx.fillRect(x + 2, y + windowHeight / 2 - 1, windowWidth - 4, 2);
    ctx.fillRect(x + windowWidth / 2 - 1, y + 2, 2, windowHeight - 4);

    // Ramki okna
    ctx.strokeStyle = "#0a0a0a";
    ctx.lineWidth = 1;
    ctx.strokeRect(x, y, windowWidth, windowHeight);
    ctx.strokeStyle = "#151515";
    ctx.strokeRect(x + 2, y + 2, windowWidth - 4, windowHeight - 4);
  }

  drawBuildingEntrance() {
    // Tabliczka z adresem
    ctx.fillStyle = "#3a3a3a";
    ctx.fillRect(380, 220, 80, 25);
    ctx.strokeStyle = "#2a2a2a";
    ctx.lineWidth = 2;
    ctx.strokeRect(380, 220, 80, 25);

    ctx.fillStyle = "#ddd";
    ctx.font = "bold 12px monospace";
    ctx.textAlign = "center";
    ctx.fillText("CMENTARNA 5", 420, 237);

    // Drzwi wej≈õciowe
    ctx.fillStyle = "#2a1a0a";
    ctx.fillRect(390, 250, 60, 120);

    // Rama drzwi
    ctx.fillStyle = "#4a3a2a";
    ctx.fillRect(385, 245, 70, 130);
    ctx.fillStyle = "#2a1a0a";
    ctx.fillRect(390, 250, 60, 120);

    // Panele na drzwiach
    ctx.fillStyle = "#1a0a00";
    ctx.fillRect(395, 260, 25, 35);
    ctx.fillRect(425, 260, 20, 35);
    ctx.fillRect(395, 310, 25, 35);
    ctx.fillRect(425, 310, 20, 35);

    // Ramki paneli
    ctx.strokeStyle = "#0a0a0a";
    ctx.lineWidth = 1;
    ctx.strokeRect(395, 260, 25, 35);
    ctx.strokeRect(425, 260, 20, 35);
    ctx.strokeRect(395, 310, 25, 35);
    ctx.strokeRect(425, 310, 20, 35);

    // Klamka
    ctx.fillStyle = "#8a7a5a";
    ctx.fillRect(440, 325, 6, 8);

    // Schody
    ctx.fillStyle = "#3a3a3a";
    ctx.fillRect(385, 370, 70, 8);
    ctx.fillRect(390, 378, 60, 8);
    ctx.fillRect(395, 386, 50, 8);

    // Domofon obok drzwi
    ctx.fillStyle = "#4a4a4a";
    ctx.fillRect(475, 290, 25, 40);
    ctx.fillStyle = "#2a2a2a";
    ctx.fillRect(477, 292, 21, 36);
    ctx.fillStyle = "#6a6a6a";
    ctx.fillRect(482, 305, 11, 8);
    ctx.fillStyle = "#8a8a8a";
    ctx.fillRect(484, 307, 2, 1);
    ctx.fillRect(487, 307, 2, 1);
    ctx.fillRect(490, 307, 2, 1);
  }

  drawSewerGrate() {
    const grateX = 350,
      grateY = 450;

    // Podstawa kratki - betonowa ramka (wytarta)
    ctx.fillStyle = "#3a3a3a";
    ctx.fillRect(grateX + 10, grateY + 20, 80, 80);

    // Wewnƒôtrzna czƒô≈õƒá kratki (g≈Çƒôboka)
    ctx.fillStyle = "#0a0a0a";
    ctx.fillRect(grateX + 15, grateY + 25, 70, 70);

    // Cienie w g≈Çƒôbi
    ctx.fillStyle = "#050505";
    ctx.fillRect(grateX + 20, grateY + 30, 60, 60);

    // Kratka - pionowe prƒôty (metalowe, rdzawe)
    for (let i = 0; i < 6; i++) {
      ctx.fillStyle = "#4a4a4a";
      ctx.fillRect(grateX + 20 + i * 10, grateY + 25, 3, 70);
      // Rdza na prƒôtach
      ctx.fillStyle = "#6a3a1a";
      ctx.fillRect(grateX + 20 + i * 10, grateY + 30 + i * 8, 3, 4);
      ctx.fillRect(grateX + 20 + i * 10, grateY + 50 + i * 5, 1, 8);
    }

    // Kratka - poziome prƒôty
    for (let i = 0; i < 6; i++) {
      ctx.fillStyle = "#4a4a4a";
      ctx.fillRect(grateX + 15, grateY + 30 + i * 10, 70, 3);
      // Rdza na poziomych prƒôtach
      ctx.fillStyle = "#6a3a1a";
      ctx.fillRect(grateX + 25 + i * 7, grateY + 30 + i * 10, 6, 3);
      ctx.fillRect(grateX + 45 + i * 4, grateY + 30 + i * 10, 4, 1);
    }

    // ≈öruby w rogach (stare, zardzewia≈Çe)
    ctx.fillStyle = "#5a5a5a";
    ctx.fillRect(grateX + 12, grateY + 22, 4, 4);
    ctx.fillRect(grateX + 84, grateY + 22, 4, 4);
    ctx.fillRect(grateX + 12, grateY + 94, 4, 4);
    ctx.fillRect(grateX + 84, grateY + 94, 4, 4);

    // Rdza na ≈õrubach
    ctx.fillStyle = "#5a2a0a";
    ctx.fillRect(grateX + 13, grateY + 23, 2, 2);
    ctx.fillRect(grateX + 85, grateY + 23, 2, 2);
    ctx.fillRect(grateX + 13, grateY + 95, 2, 2);
    ctx.fillRect(grateX + 85, grateY + 95, 2, 2);

    // K≈Ç√≥dka na kratce (je≈õli nie zosta≈Ça otwarta)
    if (!gameState.wellOpened) {
      // ≈Åa≈Ñcuch przez kratkƒô
      ctx.fillStyle = "#3a3a3a";
      ctx.fillRect(grateX + 35, grateY + 45, 30, 3);
      ctx.fillRect(grateX + 35, grateY + 65, 30, 3);

      // Ogniwa ≈Ça≈Ñcucha
      for (let i = 0; i < 6; i++) {
        ctx.strokeStyle = "#2a2a2a";
        ctx.lineWidth = 2;
        ctx.strokeRect(grateX + 37 + i * 5, grateY + 44, 3, 5);
        ctx.strokeRect(grateX + 37 + i * 5, grateY + 64, 3, 5);
      }

      // K≈Ç√≥dka (solidna, stara)
      ctx.fillStyle = "#4a4a2a";
      ctx.fillRect(grateX + 40, grateY + 50, 20, 15);

      // Ramka k≈Ç√≥dki
      ctx.strokeStyle = "#6a6a4a";
      ctx.lineWidth = 2;
      ctx.strokeRect(grateX + 40, grateY + 50, 20, 15);

      // Ucho k≈Ç√≥dki
      ctx.strokeStyle = "#5a5a3a";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(grateX + 50, grateY + 48, 8, Math.PI, 0);
      ctx.stroke();

      // Dziurka na klucz
      ctx.fillStyle = "#1a1a1a";
      ctx.fillRect(grateX + 48, grateY + 55, 4, 6);

      // Napis na k≈Ç√≥dce
      ctx.fillStyle = "#6a6a6a";
      ctx.font = "8px monospace";
      ctx.textAlign = "center";
      ctx.fillText("1947", grateX + 50, grateY + 62);

      // Rdza na k≈Ç√≥dce
      ctx.fillStyle = "#5a2a0a";
      ctx.fillRect(grateX + 42, grateY + 52, 3, 2);
      ctx.fillRect(grateX + 55, grateY + 58, 2, 3);
    }

    // Cie≈Ñ kratki na ziemi
    ctx.fillStyle = "rgba(0,0,0,0.3)";
    ctx.fillRect(grateX + 92, grateY + 25, 8, 80);
    ctx.fillRect(grateX + 15, grateY + 102, 80, 8);

    // Mech i brud wok√≥≈Ç kratki
    ctx.fillStyle = "#2a3a1a";
    ctx.fillRect(grateX + 8, grateY + 18, 3, 2);
    ctx.fillRect(grateX + 85, grateY + 95, 4, 3);
    ctx.fillRect(grateX + 12, grateY + 100, 2, 2);
  }

  drawSpade() {
    const spadeX = 320,
      spadeY = 480;

    // Trzonek ≈Çopatki (drewniany, wytarty)
    ctx.fillStyle = "#8a6a4a";
    ctx.fillRect(spadeX + 10, spadeY, 4, 35);

    // S≈Çoje drewna
    ctx.fillStyle = "#7a5a3a";
    ctx.fillRect(spadeX + 10, spadeY + 5, 4, 1);
    ctx.fillRect(spadeX + 10, spadeY + 12, 4, 1);
    ctx.fillRect(spadeX + 10, spadeY + 20, 4, 1);
    ctx.fillRect(spadeX + 10, spadeY + 28, 4, 1);

    // Wytarcia na trzonku
    ctx.fillStyle = "#6a4a2a";
    ctx.fillRect(spadeX + 11, spadeY + 8, 2, 8);
    ctx.fillRect(spadeX + 11, spadeY + 18, 2, 6);

    // Metalowa czƒô≈õƒá (≈ºelazna, u≈ºywana)
    ctx.fillStyle = "#5a5a5a";
    ctx.fillRect(spadeX + 6, spadeY + 30, 12, 8);

    // Odblaski na metalu
    ctx.fillStyle = "#7a7a7a";
    ctx.fillRect(spadeX + 7, spadeY + 31, 2, 1);
    ctx.fillRect(spadeX + 15, spadeY + 33, 2, 1);

    // Rdza na metalu
    ctx.fillStyle = "#5a2a0a";
    ctx.fillRect(spadeX + 6, spadeY + 35, 2, 2);
    ctx.fillRect(spadeX + 16, spadeY + 32, 1, 3);

    // Krawƒôd≈∫ robocza (ostra)
    ctx.fillStyle = "#4a4a4a";
    ctx.fillRect(spadeX + 7, spadeY + 37, 10, 1);

    // Uchwyt (owiniƒôty sznurkiem)
    ctx.fillStyle = "#6a4a2a";
    ctx.fillRect(spadeX + 8, spadeY - 2, 8, 6);

    // Owiniƒôcie sznurkiem
    ctx.fillStyle = "#5a3a1a";
    ctx.fillRect(spadeX + 8, spadeY - 1, 8, 1);
    ctx.fillRect(spadeX + 8, spadeY + 1, 8, 1);
    ctx.fillRect(spadeX + 8, spadeY + 3, 8, 1);

    // Ko≈Ñc√≥wka sznurka
    ctx.fillStyle = "#4a2a0a";
    ctx.fillRect(spadeX + 16, spadeY + 2, 2, 2);

    // Cie≈Ñ ≈Çopatki
    ctx.fillStyle = "rgba(0,0,0,0.3)";
    ctx.fillRect(spadeX + 15, spadeY + 5, 3, 30);
    ctx.fillRect(spadeX + 19, spadeY + 32, 3, 6);

    // Ziemia na ≈Çopatce (u≈ºywana)
    ctx.fillStyle = "#3a2a1a";
    ctx.fillRect(spadeX + 8, spadeY + 34, 3, 2);
    ctx.fillRect(spadeX + 14, spadeY + 35, 2, 1);
  }

  drawBushes() {
    // Krzak pierwszy (po prawej stronie) - przesuniƒôty na d√≥≈Ç
    const bush1X = 580,
      bush1Y = 520;

    // G≈Ç√≥wna masa krzaka
    ctx.fillStyle = "#2a4a1a";
    ctx.beginPath();
    ctx.ellipse(bush1X + 15, bush1Y + 15, 18, 12, 0, 0, 2 * Math.PI);
    ctx.fill();

    // Dodatkowe kule li≈õci
    ctx.fillStyle = "#3a5a2a";
    ctx.beginPath();
    ctx.ellipse(bush1X + 8, bush1Y + 12, 8, 6, 0, 0, 2 * Math.PI);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(bush1X + 22, bush1Y + 18, 10, 8, 0, 0, 2 * Math.PI);
    ctx.fill();

    // Krzak drugi (wiƒôkszy, dalej) - przesuniƒôty na d√≥≈Ç
    const bush2X = 620,
      bush2Y = 530;
    ctx.fillStyle = "#2a4a1a";
    ctx.beginPath();
    ctx.ellipse(bush2X + 20, bush2Y + 12, 22, 15, 0, 0, 2 * Math.PI);
    ctx.fill();
    ctx.fillStyle = "#3a5a2a";
    ctx.beginPath();
    ctx.ellipse(bush2X + 10, bush2Y + 8, 12, 8, 0, 0, 2 * Math.PI);
    ctx.fill();

    // Ma≈Çe krzaczki przy g≈Ç√≥wnych - przesuniƒôte na d√≥≈Ç
    const smallBushX = 600,
      smallBushY = 540;
    ctx.fillStyle = "#2a3a1a";
    ctx.beginPath();
    ctx.ellipse(smallBushX + 8, smallBushY + 6, 8, 5, 0, 0, 2 * Math.PI);
    ctx.fill();

    // Kopczyk ziemi przy krzakach (drugi kopczyk) - przesuniƒôty na d√≥≈Ç
    if (!gameState.hasBone) {
      const mound2X = 650,
        mound2Y = 560;
      ctx.fillStyle = "#4a3a2a";
      ctx.beginPath();
      ctx.ellipse(mound2X + 8, mound2Y + 6, 8, 5, 0, 0, 2 * Math.PI);
      ctx.fill();
      ctx.fillStyle = "#5a4a3a";
      ctx.beginPath();
      ctx.ellipse(mound2X + 8, mound2Y + 4, 5, 3, 0, 0, 2 * Math.PI);
      ctx.fill();

      // Grudki przy drugim kopczyku
      ctx.fillStyle = "#3a2a1a";
      ctx.fillRect(mound2X + 5, mound2Y + 8, 2, 1);
      ctx.fillRect(mound2X + 12, mound2Y + 9, 2, 1);
      ctx.fillRect(mound2X + 3, mound2Y + 7, 1, 1);
    }

    // Ko≈õƒá - je≈õli zosta≈Ça wykopana i jest widoczna - przesuniƒôta na d√≥≈Ç
    if (gameState.hasBone && gameState.boneVisible) {
      const boneX = 655,
        boneY = 565;

      // G≈Ç√≥wna czƒô≈õƒá ko≈õci
      ctx.fillStyle = "#eaeaea";
      ctx.fillRect(boneX, boneY, 12, 4);

      // Ko≈Ñc√≥wki ko≈õci (kuliste)
      ctx.fillStyle = "#f0f0f0";
      ctx.beginPath();
      ctx.arc(boneX + 1, boneY + 2, 3, 0, 2 * Math.PI);
      ctx.fill();
      ctx.beginPath();
      ctx.arc(boneX + 11, boneY + 2, 3, 0, 2 * Math.PI);
      ctx.fill();

      // Szczeg√≥≈Çy ko≈õci (pƒôkniƒôcia)
      ctx.fillStyle = "#d0d0d0";
      ctx.fillRect(boneX + 3, boneY + 1, 1, 1);
      ctx.fillRect(boneX + 7, boneY + 3, 1, 1);
      ctx.fillRect(boneX + 9, boneY + 1, 1, 1);

      // Cie≈Ñ ko≈õci
      ctx.fillStyle = "rgba(0,0,0,0.2)";
      ctx.fillRect(boneX + 1, boneY + 5, 10, 2);
    }
  }

  drawJanitor(x, y) {
    // Buty robocze
    ctx.fillStyle = "#1a1a1a";
    ctx.fillRect(x + 14, y + 118, 8, 6);
    ctx.fillRect(x + 34, y + 118, 8, 6);

    // Nogi w po≈Ñczochach
    ctx.fillStyle = "#3a3a4a";
    ctx.fillRect(x + 16, y + 85, 6, 33);
    ctx.fillRect(x + 36, y + 85, 6, 33);

    // Sp√≥dnica robocza
    ctx.fillStyle = "#2a2a5a";
    ctx.fillRect(x + 8, y + 70, 42, 20);

    // Wz√≥r na sp√≥dnicy
    ctx.fillStyle = "#1a1a4a";
    ctx.fillRect(x + 15, y + 72, 2, 16);
    ctx.fillRect(x + 25, y + 72, 2, 16);
    ctx.fillRect(x + 35, y + 72, 2, 16);

    // Tu≈Ç√≥w w bluzie
    ctx.fillStyle = "#4a4a6a";
    ctx.fillRect(x + 12, y + 45, 34, 30);

    // Fartuch roboczy
    ctx.fillStyle = "#6a6a7a";
    ctx.fillRect(x + 10, y + 50, 38, 25);

    // Rƒôce
    ctx.fillStyle = "#7a6a5a";
    ctx.fillRect(x + 4, y + 48, 8, 25);
    ctx.fillRect(x + 46, y + 48, 8, 25);

    // Szyja
    ctx.fillStyle = "#8a7a6a";
    ctx.fillRect(x + 22, y + 40, 14, 8);

    // G≈Çowa
    ctx.fillStyle = "#8a7a6a";
    ctx.fillRect(x + 18, y + 20, 22, 25);

    // Chustka na g≈Çowie
    ctx.fillStyle = "#6a5a5a";
    ctx.fillRect(x + 16, y + 20, 26, 12);

    // Kropki na chustce
    ctx.fillStyle = "#7a6a6a";
    ctx.fillRect(x + 18, y + 22, 2, 2);
    ctx.fillRect(x + 24, y + 24, 2, 2);
    ctx.fillRect(x + 30, y + 22, 2, 2);

    // Oczy
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(x + 22, y + 28, 4, 3);
    ctx.fillRect(x + 30, y + 28, 4, 3);
    ctx.fillStyle = "#2a2a2a";
    ctx.fillRect(x + 23, y + 29, 2, 2);
    ctx.fillRect(x + 31, y + 29, 2, 2);

    // Nos
    ctx.fillStyle = "#7a6a5a";
    ctx.fillRect(x + 27, y + 32, 2, 3);

    // Usta (u≈õmiech)
    ctx.fillStyle = "#5a3a3a";
    ctx.fillRect(x + 26, y + 36, 4, 2);

    // Wiadro
    ctx.fillStyle = "#8a6a4a";
    ctx.fillRect(x - 12, y + 88, 16, 20);

    // Woda w wiadrze
    ctx.fillStyle = "#4a6a8a";
    ctx.fillRect(x - 10, y + 89, 12, 14);

    // Mop
    ctx.fillStyle = "#8a6a4a";
    ctx.fillRect(x + 50, y + 30, 3, 40);

    // G≈Ç√≥wka mopa
    ctx.fillStyle = "#6a6a5a";
    ctx.fillRect(x + 48, y + 26, 7, 8);
  }
  drawNeighbor(x, y) {
    // Buty
    ctx.fillStyle = "#1a1a1a";
    ctx.fillRect(x + 14, y + 138, 10, 6);
    ctx.fillRect(x + 34, y + 138, 10, 6);

    // Spodnie robocze
    ctx.fillStyle = "#3a3a4a";
    ctx.fillRect(x + 15, y + 90, 14, 48);
    ctx.fillRect(x + 35, y + 90, 14, 48);

    // Kurtka robocza
    ctx.fillStyle = "#4a5a3a";
    ctx.fillRect(x + 10, y + 45, 45, 50);

    // Rƒôce
    ctx.fillStyle = "#7a6a5a";
    ctx.fillRect(x + 5, y + 50, 10, 30);
    ctx.fillRect(x + 50, y + 50, 10, 30);

    // Szyja
    ctx.fillStyle = "#8a7a6a";
    ctx.fillRect(x + 24, y + 40, 16, 8);

    // G≈Çowa
    ctx.fillStyle = "#8a7a6a";
    ctx.fillRect(x + 20, y + 15, 25, 30);

    // W≈Çosy
    ctx.fillStyle = "#4a3a2a";
    ctx.fillRect(x + 18, y + 15, 29, 12);

    // Oczy
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(x + 24, y + 25, 4, 3);
    ctx.fillRect(x + 32, y + 25, 4, 3);
    ctx.fillStyle = "#2a2a2a";
    ctx.fillRect(x + 25, y + 26, 2, 2);
    ctx.fillRect(x + 33, y + 26, 2, 2);

    // WƒÖsy
    ctx.fillStyle = "#3a2a1a";
    ctx.fillRect(x + 26, y + 34, 8, 3);

    // PIES BUREK
    const dogX = x + 80,
      dogY = y + 80;

    // Cia≈Ço psa
    ctx.fillStyle = "#4a3a2a";
    ctx.fillRect(dogX, dogY, 45, 25);

    // ≈Åapy
    ctx.fillStyle = "#3a2a1a";
    ctx.fillRect(dogX + 5, dogY + 20, 6, 15);
    ctx.fillRect(dogX + 15, dogY + 20, 6, 15);
    ctx.fillRect(dogX + 30, dogY + 20, 6, 15);
    ctx.fillRect(dogX + 40, dogY + 20, 6, 15);

    // G≈Çowa psa
    ctx.fillStyle = "#5a4a3a";
    ctx.fillRect(dogX + 35, dogY - 8, 20, 18);

    // Pysk
    ctx.fillStyle = "#4a3a2a";
    ctx.fillRect(dogX + 50, dogY - 5, 8, 10);

    // Nos psa
    ctx.fillStyle = "#1a1a1a";
    ctx.fillRect(dogX + 55, dogY - 3, 3, 3);

    // Oczy psa
    ctx.fillStyle = "#1a1a1a";
    ctx.fillRect(dogX + 40, dogY - 3, 2, 2);
    ctx.fillRect(dogX + 46, dogY - 3, 2, 2);

    // Ogon
    ctx.fillStyle = "#4a3a2a";
    ctx.fillRect(dogX - 8, dogY + 5, 10, 6);
  }
  drawPostman(x, y) {
    // Buty s≈Çu≈ºbowe
    ctx.fillStyle = "#1a1a1a";
    ctx.fillRect(x + 14, y + 123, 10, 6);
    ctx.fillRect(x + 34, y + 123, 10, 6);

    // Spodnie s≈Çu≈ºbowe (granatowe)
    ctx.fillStyle = "#2a2a4a";
    ctx.fillRect(x + 15, y + 80, 14, 43);
    ctx.fillRect(x + 35, y + 80, 14, 43);

    // Kurtka s≈Çu≈ºbowa
    ctx.fillStyle = "#3a4a5a";
    ctx.fillRect(x + 12, y + 45, 41, 40);

    // Guziki (z≈Çote)
    ctx.fillStyle = "#6a6a2a";
    for (let i = 0; i < 4; i++) {
      ctx.fillRect(x + 26, y + 50 + i * 8, 3, 3);
      ctx.fillRect(x + 36, y + 50 + i * 8, 3, 3);
    }

    // Rƒôce
    ctx.fillStyle = "#7a6a5a";
    ctx.fillRect(x + 5, y + 50, 10, 25);
    ctx.fillRect(x + 50, y + 50, 10, 25);

    // Szyja
    ctx.fillStyle = "#8a7a6a";
    ctx.fillRect(x + 24, y + 40, 16, 8);

    // G≈Çowa
    ctx.fillStyle = "#8a7a6a";
    ctx.fillRect(x + 20, y + 15, 25, 30);

    // Czapka s≈Çu≈ºbowa
    ctx.fillStyle = "#3a4a3a";
    ctx.fillRect(x + 18, y + 15, 29, 18);

    // Daszek czapki
    ctx.fillStyle = "#2a3a2a";
    ctx.fillRect(x + 15, y + 25, 35, 6);

    // Oczy
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(x + 24, y + 28, 4, 3);
    ctx.fillRect(x + 32, y + 28, 4, 3);
    ctx.fillStyle = "#2a2a2a";
    ctx.fillRect(x + 25, y + 29, 2, 2);
    ctx.fillRect(x + 33, y + 29, 2, 2);

    // WƒÖsy
    ctx.fillStyle = "#3a3a2a";
    ctx.fillRect(x + 26, y + 36, 8, 2);

    // Torba pocztowa
    ctx.fillStyle = "#6a4a2a";
    ctx.fillRect(x - 18, y + 50, 22, 30);

    // Listy w rƒôku
    ctx.fillStyle = "#eaeaea";
    ctx.fillRect(x + 52, y + 65, 6, 10);
    ctx.fillRect(x + 54, y + 63, 6, 10);

    // Znaczki na listach
    ctx.fillStyle = "#aa2a2a";
    ctx.fillRect(x + 54, y + 64, 2, 2);
    ctx.fillRect(x + 57, y + 62, 2, 2);
  }
}
class ApartmentScene extends Scene {
  constructor() {
    super();
    this.addArea(650, 300, 100, 200, () => changeScene("ending"));
  }

  render() {
    ctx.fillStyle = "#2a2a1a";
    ctx.fillRect(0, 0, 800, 600);

    ctx.fillStyle = "#e0e0ff";
    ctx.font = "20px Georgia";
    ctx.textAlign = "center";
    ctx.fillText("Mieszkanie Starzika", 400, 300);
    ctx.fillText("Kliknij na wyj≈õcie ‚Üí", 400, 330);

    if (this.hoveredArea) {
      ctx.fillStyle = "rgba(255, 255, 255, 0.1)";
      ctx.fillRect(
        this.hoveredArea.x,
        this.hoveredArea.y,
        this.hoveredArea.w,
        this.hoveredArea.h
      );
    }
  }
}

class EndingScene extends Scene {
  constructor() {
    super();
    this.alpha = 0;
    this.addArea(0, 0, 800, 600, () => {
      changeScene("menu");
      inventory = [];
      gameState = {
        hasSpade: false,
        hasBone: false,
        boneVisible: false,
        gaveBone: false,
        gotInfo: false,
        gotCode: false,
        wellOpened: false,
        hasID: false,
        gotLetter: false,
        canEnter: false,
        intercomUnlocked: false,
        hasIntercomCode: false
      };
      updateInventoryDisplay();
      this.alpha = 0;
    });
  }

  render() {
    const gradient = ctx.createLinearGradient(0, 0, 0, 600);
    gradient.addColorStop(0, "#4a4a6a");
    gradient.addColorStop(1, "#2a2a4a");
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, 800, 600);

    this.alpha += 0.01;
    if (this.alpha > 1) this.alpha = 1;

    if (this.alpha > 0.8) {
      ctx.fillStyle =
        "rgba(255, 255, 255, " + Math.min(1, (this.alpha - 0.8) * 5) + ")";
      ctx.font = "24px Georgia";
      ctx.textAlign = "center";
      ctx.fillText("Starzik wyrusza w podr√≥≈º...", 400, 500);

      ctx.font = "16px Georgia";
      ctx.fillText("Co zosta≈Ço w jego mieszkaniu?", 400, 530);
      ctx.fillText("Przekonaj siƒô w escape roomie Familock!", 400, 550);
    }

    if (this.hoveredArea) {
      ctx.fillStyle = "rgba(255, 255, 255, 0.1)";
      ctx.fillRect(
        this.hoveredArea.x,
        this.hoveredArea.y,
        this.hoveredArea.w,
        this.hoveredArea.h
      );
    }
  }
}

function gameLoop() {
  try {
    if (!ctx || !canvas) {
      console.error("Canvas or context not available!");
      return;
    }

    ctx.clearRect(0, 0, 800, 600);

    if (scenes && scenes[currentScene] && scenes[currentScene].render) {
      scenes[currentScene].render();
    } else {
      console.error("Scene not found:", currentScene);
      ctx.fillStyle = "#ff0000";
      ctx.fillRect(100, 100, 200, 100);
      ctx.fillStyle = "#ffffff";
      ctx.font = "20px Arial";
      ctx.fillText("Error: Scene not found", 110, 150);
    }

    requestAnimationFrame(gameLoop);
  } catch (error) {
    console.error("Error in gameLoop:", error);
    log("‚ùå B≈ÇƒÖd w gameLoop: " + error.message);
    setTimeout(() => {
      requestAnimationFrame(gameLoop);
    }, 1000);
  }
}

document.addEventListener("DOMContentLoaded", function () {
  console.log("DOM loaded, starting game initialization...");
  setTimeout(() => {
    try {
      const result = initGame();
      if (result) {
        log("üéâ Gra za≈Çadowana!");
        console.log("Game started successfully!");
      } else {
        log("‚ùå B≈ÇƒÖd ≈Çadowania gry");
        console.error("Game failed to start");
      }
    } catch (error) {
      console.error("Critical error:", error);
      log("‚ùå Krytyczny b≈ÇƒÖd: " + error.message);
    }
  }, 100);
});
